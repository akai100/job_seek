# xTaskCreate
## 参数
## 实现
步骤 1：如果栈向下增长：

步骤 1.1：为任务TCB分配空间，并初始化空间为0；

步骤 1.2：为任务分配栈空间，

步骤 2：否则：

步骤 2.1：为任务分配栈空间；

步骤 2.2：为任务TCB分配空间，并初始化空间为0；

步骤 3：初始化TCB；

步骤 3.1：启用内存保护单元（MPU）：

步骤 3.1.1：任务优先级为特权模式下优先级；

步骤 3.1.2：重新计算任务优先级；

步骤 3.2：需要初始化栈为已知值：

步骤 3.2.1：初始化栈空间为已知值；

步骤 3.3：如果栈向下增长：

步骤 3.3.1：栈顶为栈高地址；

步骤 3.3.2：如果需要记录栈高地址，则保存栈高地址；

步骤 3.4：否则：

步骤 3.4.1：

步骤 3.4：如果任务名不为空：

步骤 3.5：保存任务优先级到 TCB：

步骤 3.6：如果开启互斥锁：

步骤 3.6.1 保存优先级值到任务base优先级字段；

步骤 3.7：初始化TCB列表；

步骤 3.8：如果启动内存保护单元：

步骤 3.8.1：初始化TCB mpu设置;

步骤 3.9：如果 TLS

步骤 3.9.1：

步骤 3.10：如果开启内存保护单元：

步骤 3.10.1：如果开启栈溢出检查：

步骤 3.10.1.1：如果栈向下增长：

步骤 3.10.1.1.1：

步骤 3.11：未开启内存保护单元：

# vTaskStartScheduler
## 参数
## 功能
启动RTOS任务调度
## 实现
步骤 1：

步骤 2：调用接口```prvCreateIdleTasks```创建空闲任务;

步骤 3：如果启动软件定时器，调用接口 ```xTimerCreateTimerTask```创建定时器任务；

步骤 4：任务创建时执行额外的自定义初始化操作；

步骤 5：关闭中断；

步骤 6：调用接口 ```xPortStartScheduler```启用任务调度器；

# xPortStartScheduler
## 参数
## 功能
## 实现
步骤 1：

步骤 2：调用```vPortSetupTimerInterrupt```接口，用于配置硬件定时器以产生固定频率的中断，这些中断将驱动操作系统的任务调度；

步骤 3：如果定义了mtime寄存器地址和mtimecmp寄存器地址，使能机器模式下的定时器中断和外部中断；

步骤 4：调用```xPortStartFirstTask```接口，启动第一个任务；

## 解释
### 为什么需要显示启动第一个任务？
+ 调度器启动前，系统处于"无任务运行"状态；
+ 没有任务上下文，CPU 不知道从哪里开始执；
+ 需手动加载首个任务的上下文（栈指针/寄存器/入口点）；
+
### mtime和mtimecmp
RISC-V 规范定义了 `mtime` 和 `mtimecmp` 寄存器，用于产生定时中断（如系统节拍中断）。

mtime：`mtime` 是一个 64 位只读寄存器，提供当前计时器的计数值；

mtimecmp`：是一个 64 位读写寄存器，用于设置下一次定时中断的触发时间；

# xPortStartFirstTask
## 参数
## 功能
通过模拟中断返回机制，将 CPU 上下文切换到第一个任务。
## 实现
步骤 1：加载当前任务控制块指针；

步骤 2：恢复任务上下文（模拟中断返回）；

步骤 3：恢复关键系统寄存器；

步骤 4：调整栈指针（调过已恢复的上下文）；

步骤 5：强制返回用户模式并跳转到任务；
## 解释
# vTaskSwitchContext - 单核
## 参数
## 功能
任务调度时，选择下一个要运行的任务；
## 实现
步骤 1：任务调度器挂起：

步骤 2：任务调度器未挂起：

步骤 2.1：如果启用运行时任务统计功能：

步骤 2.1.1：

步骤 2.2：检查栈溢出

步骤 2.3：高效选择最高优先级就绪任务；

步骤 2.3.1：从当前就绪任务选最高优先级开始遍历继续队列；

步骤 2.3.2：设置当前任务控制块；

# vTaskSwitchContext-多核
## 参数
## 功能
## 实现
步骤 1：获取任务锁；

步骤 2：获取ISR锁；

步骤 3：任务调度器挂起：

步骤 4：任务调度器未挂起：

步骤 4.1：如果启用运行时任务统计功能：

步骤 4.2：检查栈溢出；

步骤 4.3：调用```prvSelectHighestPriorityTask```接口选择最高优先级任务

步骤 5：释放ISR锁；

步骤 6：释放任务锁；

# prvSelectHighestPriorityTask
## 参数
## 功能
## 实现
步骤 1：如果配置核亲和度为1，

步骤 2：配置未开启运行多优先级

步骤 3：如果当前任务的当前任务同优先级就绪队列包含当前任务

步骤 3.1：

步骤 3.2：

步骤 4：

步骤 4.1：当前优先级就绪队列不为空：

步骤 4.1.1：遍历当前优先级就绪队里：

步骤 4.1.1.1：当前就绪任务处于非运行态：

步骤 4.1.1.1.1：如果核亲和度值不为1或则当前就绪任务

步骤 4.1.1.1.1.1：设置当前运行任务的运行状态为非运行态；

步骤 4.1.1.1.1.2：如果核亲和度配置为1：

步骤 4.1.1.1.1.3：当前就绪任务的运行状态设置为CoreID；

当前 4.1.1.1.1.4：当前运行指针指向当前就绪任务；

步骤 4.1.1.2：当前就绪任务等于当前运行任务：

步骤 4.1.1.2.1：如果核亲和度不为1或者当前就绪任务核亲和度掩码

步骤 4.1.1.3：否则：

# prvCreateIdleTasks
## 参数
## 功能
创建空闲任务
## 实现
步骤 1：
步骤 2：对core0 ~ coren,

# prvIdleTask
## 参数
## 功能
## 实现

# prvCheckForRunStateChange
## 参数
## 功能
负责检测任务状态变化并触发必要的调度操作， 
## 实现







