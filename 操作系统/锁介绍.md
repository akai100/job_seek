# 1. 互斥锁
## 基本原理
互斥锁是最基础的同步机制，用于确保同一时间只有一个线程能访问共享资源；
## 工作原理
加锁：线程尝试获取锁，若锁已被占用，则进入阻塞状态（休眠），直到锁被释放；
解锁：持有锁的线程释放锁后，操作系统会唤醒一个等待线程；
## 使用场景
+ 适用于临界区执行之间比较长的场景
+ 通用性强，适合大多数用户态程序；
## 优缺点
优点：避免 CPU 空转，节省计算资源；
缺点：上下文切换开销较大，不适合高频临界区操作；

# 2. 自旋锁
## 基本概念
自旋锁通过忙等待实现同步，线程在获取锁失败时会持续轮询，直到锁可用。

## 工作原理
线程通过原子操作（如CAS）尝试获取锁，若失败，则循环检查锁状态，不放弃CPU。

## 使用场景
+ 临界资源（纳秒~微妙），如内核数据结构
+ 多核CPU环境，避免线程切换的开销；

## 优缺点
+ 优点：无上下文切换，响应速度快；
+ 缺点：单核CPU上会导致死锁，长时间自选浪费CPU；

# 3. 读写锁
## 基本概念
工读写锁区分读操作和写操作，允许多个线程并发访问，但写操作必须独占资源。

## 工作原理
读模式：多个线程可同时持有读锁；
写模式：仅有一个线程可以持有写锁，且与读锁互斥；

## 使用场景
读多写少的场景（如缓存数据库）

## 优缺点
优点：提高读操作的并发性；
缺点：实现复杂，可能引发写线程饥饿；

# 4. 条件变量
## 基本概念
条件变量用于线程间的条件同步，通常与互斥锁配合使用，实现等待-通知机制

## 工作原理
+ 线程在条件不满足时调用 wait 进入阻塞状态；
+ 当所有线程通过 signal 或 broadcast 唤醒等待线程；

## 适用场景
+ 生产者-消费者模型、线程池任务调度

## 优缺点
优点：灵活支持复杂同步逻辑；
缺点：使用不当易导致死锁（如虚假唤醒）

# 5. 悲观锁
## 基本概念
悲观锁是一种“先获取再访问”的并发控制策略，它假设并发访问很可能会发生冲突，因此在访问数据前会先加锁，确保独占访问

## 工作原理
线程在访问共享资源前必须先获取锁；
在持有锁期间，其他线程无法访问资源
操作完成后释放锁；

# 6. 乐观锁
