```mermaid
mindmap
C++
    基础语法
        函数
            内联函数
            函数模板
                语法
                    template <class T>
                    template <typename T>
                class和typename差异
                    选择建议
                        class常见于旧代码（历史遗留习惯）
                        typename 更直观，明确表示“类型名”（推荐使用）
                        嵌套类型必须使用 typename
                            template<class T> void print(const T& cntainer)
                        模板模板参数仅支持class
                            template <template <typename Elem> class Container>
                显示具体化
                    第三代具体化
                        对于给定的函数名，可以有非模板函数、模板函数和显示具体化模板函数以及它们的重载版本
                        显示具体化的原型和定义应以template<>打头，并通过名称来指出类型
                        具体化将覆盖常规模板，而非模板函数将覆盖具体化和常规模板
                实例化和具体化
                    隐式实例化
                        通过函数参数类型生成
                    显示实例化

        内存模型和名称空间
            存储持续性、作用域和链接性
                作用域和链接
                    链接性描述了名称如何在不同单元间共享，链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享
                自动存储持续性
                    自动变量的初始化
                    自动变量和堆栈
            寄存器变量
                通过使用CPU寄存器而不是堆栈来处理特定的变量，从而提供对变量的快速访问
            静态持续变量
                在整个程序执行期间存在
                编译器分配固定的内存块来存储所有的静态变量

    C++ 11
        auto & decltype
            auto
                auto 基于变量的初始化表达式推导类型，会忽略表达式的顶层const和引用
            decltype
                decltype 基于给定表达式的完整类型推导，保留顶层const和引用
            差异
                auto必须待初始化器（否则无法推导类型）
                decltype无需初始化器，可直接声明变量"
        范围for循环
            初始化列表
                提供了一种简洁、灵活的语法来初始化数组、容器、结构体等复杂数据结构
            语法
                ["初始化数组: int arr\[] = {1, 2, 3, 4, 5};"]
                ["初始化容器：std::vector<int> vec = {1, 2, 3, 4, 5};"]
                ["初始化结构体：Point p = {10, 20};"]
        ["nullptr"]
            ["作用"]
                ["解决传统空指针表示NULL/0缺陷的重要特性，旨在提升类型安全性和代码表达清晰度"]
                ["解决重载歧义问题"]
                    ["void func(int);    // 版本1 void func(void *);      // 版本2 func(NULL);// 调用版本1，而非预期的版本2"]
                ["类型系统的一致性"]
                    ["C 语言的NULL是 (void*)0，但C++禁用void* 到其他指针类型的隐式转换，因此C++的NULL只能定义为0，丢失类型信息"]
                    ["nullptr 是类型安全的空指针常量，隐式转换为任意指针类型，避免类型混淆"]
        ["强枚举类型"]
            ["作用"]
                ["作用域隔离"]
                    ["传统枚举的成员暴露在外部作用域中，不能枚举的同名成员会冲突"]
                    ["enum class 成员必须通过枚举名访问，作用域隔离"]
                ["禁止隐式整型转换"]
                    ["传统枚举成员可隐式转换为整型，易引发逻辑错误"]
                    ["enum class 禁止隐式转换，必须显示操作"]
                ["可指定底层类型"]
                    ["传统枚举底层类型由编译器决定，可能导致跨平台问题"]
                    ["enum class 允许显示指定类型 enum class Port : uint8_t { HTTP=80, HTTPS=44 };"]
        ["编译器常量constexpr"]
        ["右值引用和移动语义"]
            ["右值引用"]
                ["用于支持移动语义和完美转发，旨在提升程序性能并优化资源管理"]
                ["左值：有持久标识符、可取地址"]
                ["右值：临时对象，无标识符、不可取地址"]
                ["纯右值"]
                ["将亡值：被标记为可移动的对象（如 std::move(a)）"]
                ["右值引用 T&&"]
                    ["绑定右值，延长其生命周期"]
                        ["int && rr = 5;"]
            ["移动语义"]
                ["避免深拷贝，直接窃取资源"]
                ["实现"]
                    ["移动构造函数：接管源对象的资源（如指针），并置空源对象"]
        ["Lambda 表达式"]
            ["本质是语法糖，编译器会将其转换为一个匿名类（闭包类型），并重载opeator()"]
            ["闭包对象"]
                ["Lambda 表达式求值后产生一个临时闭包对象，可存储或传递"]
            ["与函数指针区别"]
                ["无捕获的Lambda可隐式转换为函数指针"]
                ["有捕获的 Lambda 因携带状态，无法直接转换"]
            ["捕获列表"]
                ["值捕获"]
                    ["[x]"]
                    ["创建x的副本"]
                ["引用捕获"]
                    ["[&x]"]
                    ["直接引用外部x,修改同步生效"]
                    ["悬空引用风险"]
                ["隐式全捕获"]
                    ["[=] 或 [&]"]
                    ["自动捕获所有用到的变量（值/引用）"]
                    ["易误捕获未使用变量"]
                ["混合捕获"]
                    ["[x, &y]"]
                    ["组合值捕获和引用捕获"]
                    ["捕获this指针"]
            ["可变Lambda表达式"]
                ["默认情况下，lambda 不可修改其捕获的值，如果需要修改捕获的值，可以在捕获列表后加上 mutable 关键字"]
                ["auto lambda = [x]() mutable {"]
        ["委托构造函数"]
            ["定义"]
                ["允许一个构造函数调用同一类中的另一个构造函数，实现初始化逻辑的复用"]
            ["解决的问题"]
                ["消除多个构造函数中重复的初始化代码，提升代码简洁性和可维护性"]
            ["关键特性与规则"]
                ["初始化列表限制：委托构造函数不能有自己的成员初始化列表"]
                ["被委托的构造函数先执行，委托构造函数的函数体后执行"]
                ["避免循环委托"]
        ["default和delete"]
            ["default"]
                ["语法"]
                    ["MyClass() = default;"]
                    ["函数被定义为显式默认函数"]
                    ["显式默认化的函数必须是特殊成员函数"]
                    ["默认构造函数 MyClass()"]
                    ["拷贝构造函数 MyClass(const MyClass&)"]
                    ["拷贝赋值运算符 MyClass& operator=(const MyClass&)"]
                    ["析构函数 ~MyClass()"]
                    ["移动构造函数 MyClass(MyClass&&)（C+11新增）"]
                    ["赋值运算符 "]
                ["显示生成默认函数"]
            ["delete"]
                ["显示禁用特定函数或函数模板实例化的特性，用于增强代码的安全性和表达意图的清晰度"]
                ["语法"]
                    ["MyClass(const Myclass&) = delete;"]
                    ["void func() = delete;    // 禁用普通函数"]
                    ["void MyClass::processPointer<void>(void *) = delete;    // 禁用 void * 转化"]
                ["作用"]
                    ["禁止隐式生成函数"]
                    ["避免隐式类型转换"]
        ["final和override"]
            ["final"]
                ["指定虚函数不能在派生类中被重写，或者指定一个类不能被派生"]
                ["语法"]
                    ["virtual void show() final {}"]
            ["override"]
                ["指定一个虚函数覆盖另一个虚函数"]
                
```

    B --> B1
    B1(类和对象)
    B1 --> B11
    B11(面向对象)
    B11 --> B111
    B111(特性)
    B1111(抽象)
    B1112(封装)
    B1113(多态)
    B1114(继承)
    B111 --> B1111
    B111 --> B1112
    B111 --> B1113
    B111 --> B1114

B1 --> B12(类)
B12 --> B121(成员访问类型)
B121 --> B1211(public)
B121 --> B1212(private)
B121 --> B1213(public)

B12 --> B122(成员函数)
B122 --> B1221(const成员函数)

B12 --> B123(构造/析构函数)

B123 --> B1231(构造函数)
B1231 --> B12311(使用)
B12311 --> B123111("显示调用：Stock food = Stock(250, 1.25)")
B12311 --> B123112("隐式调用：Stock gatment(250, 1.25)")
B12311 --> B123113("不能使用对象来调用构造函数")
B1231 --> B12312(默认构造函数)
B12312 --> B123121(当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数)
B123 --> B1232(析构函数)
B1232 --> B12321(对象生命周期结束时，自动调用，负责清理工作)
B123 --> B1233(复制构造函数)
B1233 --> B12331(用于将一个对象复制到新创建的对象中)
B1233 --> B12332("语法：ClassName(const ClassName &)")
B1233 --> B12333("调用场景")
B12333 --> B123331("ClassName obj(otherObj);")
B12333 --> B123332("ClassName obj = otherObj;")
B12333 --> B123333("ClassName obj = ClassName(otherObj);")
B12333 --> B123334("ClassName *obj = new ClassName(otherObj);")
B12333 --> B123335("注意：第2、3个场景可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋值给obj，取决于具体实现")
B1233 --> B12334("功能")
B12334 --> B123331("默认的复制构造函数逐个复制非静态成员，复制的是成员的值（浅复制）")
B1231 --> B12313("成员初始化列表")
B12313 --> B1231111("Queue::Queue(int qs) : qSize(qs), front(NULL), rear(NULL), item(0)")
B12313 --> B1231112("只能用于构造函数")
B12313 --> B1231113("初始化非静态const数据成员")
B12313 --> B1231114("数据成员被初始化的顺序与它们出现在类中的顺序相同")


B12 --> B125(this指针)
B125 --> B29(指向用来调用成员函数的对象)

B12 --> B124(对象数组)
B12 --> B2(类作用域)
B2 --> B3(在类中定义的命令的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的)
B2 --> B4(静态成员变量)

B1 --> B5(操作符重载)
B5 --> B6(不能重载的操作符)
B6 --> B7(sizeof操作符)
B6 --> B8(".成员操作符")
B6 --> B9("*成员操作符")
B6 --> B10("::作用域解析操作符")
B6 --> B18("?:条件操作符")
B6 --> B17("typeid，一个RTTI操作符")
B6 --> B13("const_cast强制类型转换操作符")
B6 --> B14("dynamic_cast强制类型转换操作符")
B6 --> B15("reinterpret_cast")
B6 --> B16("static_cast")

B1 --> B19("友元")
B19 --> B20("提供另外一种形式的访问权限")
B19 --> B21("友元函数")
B19 --> B22("友元类")
B19 --> B23("友元成员函数")
B21 --> B24("让函数成员类的友元，可以赋予该函数与类的成员函数相同的访问权限")

B12 --> B25("继承")
    B25 --> B26("派生类构造函数")
B26 --> B27("基类对象首先被创建")
B26 --> B28("派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数")
B25 --> B30("派生类和基类之间的特殊关系")
B30 --> B31("基类指针可以在不进行显示类型转换的情况下指向派生类对象")
B30 --> B32("基类引用可以在不进行显示类型转换的情况下引用派生类对象")
B25 --> B33("is-a关系")
B33 --> B34("3种继承方式")
B34 --> B35("公有继承")
B34 --> B36("保护继承")
B34 --> B37("私有继承")
B25 --> B38("多态公有继承")
B38 --> B39("虚拟析构函数")
B25 --> B40("protected")
B25 --> B41("抽象基类")
B41 --> B42("纯虚函数")
B25 --> B43("私有继承")
B43 --> B44("基类的共有成员和保护成员都将称为派生类的私有成员")
    B25 --> B45("多重继承")
        B45 --> B46("虚基类")
            B46 --> B47("虚基类使得从多个类派生出的对象只继承一个基类对象")
            B46 --> B48("解决菱形继承问题")
            B46 --> B49("语法：class B : virtual public A { ... };")

B12 --> B50("类模板")
    B50 --> B51("定义类模板")
        B51 --> B52("template <class Type>")
    B50 --> B53("使用模板类")
B12 --> B54("嵌套类")
    B54 --> B55("通过提供新的类型类作用域来避免名称混乱")
    B54 --> B56("访问权限")
        B56 --> B57("作用域")
            B57 --> B58("申明在共有部分")
                B58 --> B59("包含它的类可以使用它")
                B58 --> B60("派生类可以使用")
                B58 --> B61("外部可以通过类限定符使用")
            B57 --> B62("申明在保护部分")
                B62 --> B59
                B62 --> B60
                B62 --> B63("外部不可使用")
            B57 --> B64("声明在私有部分")
                B64 --> B59
                B64 --> B65("派生类不可使用")
                B64 --> B63
        B54 --> B66("访问控制")
            B66 --> B67("对嵌套类访问权的控制规则与对常规类相同")
    B54 --> B68("模板中的嵌套")

B --> B69("异常")
    B69 --> B70("异常机制")
B --> B71("RTTI")
    B71 --> B72("RTTI 是运行阶段类型识别的简称，为程序在运行阶段确定对象的类型提供一种标准方式。")
    B71 --> B73("用途")
    B71 --> B74("原理")
B --> B75("类型转换操作符")
B --> B76("string类")
    B76 --> B77("构造字符串")
    B76 --> B78("STL")
        B78 --> B79("vector模板类")

```
