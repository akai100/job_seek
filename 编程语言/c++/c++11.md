# auto & decltype 类型推导
+ auto
  基于变量的**初始化表达式**推导类型，会**忽略**表达式的顶层const和引用；
+ decltype
  基于**给定表达式**的完整类型推导，**保留**顶层const和引用；

差异：
+ ```auto```必须待初始化器（否则无法推导类型）
+ ```decltype```无需初始化器，可直接声明变量
# 范围 for 循环

1. 介绍
简化容器或数组遍历的语法糖，通过自动处理迭代过程提升代码可读性和编写效率。
```C++
for (declaration : range) {
   statement;
}
```
+ range：可迭代对象（std::vector, std::map），也可以是数组
2. 底层实现：
```C++
auto && __range = range;
auto __begin = begin_expr(__range);     // 优先调用成员函数，否则调用全局 begin()
auto __end = end_expr(__range);
for (; __begin != __end; ++__begin) {
    declaration = *__begin;
    statement;
}
```
3. 使用建议
配合 auto 使用
+ auto &
  需修改元素或避免拷贝大对象
+ const auto &
  只读访问，提升性能
+ auto
  元素较小且无需修改时

# 初始化列表

# nullptr 关键字

# 强类型枚举（enum class）

# constexpr 编译期常量

# 有值引用和移动语义

# 默认和删除函数

# override 和 final

# lambda 表达式

# noexcept说明符
```noexcept``` 用于声明函数不会抛出异常，并提供编译期异常行为优化支持。
```c++
void f() noexcept;               // 函数 f() 不会抛出
void (*fp)() noexcept(false);    // fp 指向可能会跑出的函数
void g(void pfa() noexcept);     // g 接收指向不会抛出的函数的指针
```
编译期优化支持：

+ 编译期优化支持
  
  编译期可省略异常处理框架（如栈展开逻辑），减少指令缓存压力，提升性能。

## 使用场景与风险

推荐使用场景：

+ 移动操作
  
  移动构造/赋值函数应尽量标记```noexcept```(否则容器退化为拷贝)

+ 析构函数

  C++ 默认析构函数设为```noexcept```，手动声明会破坏兼容性

+ 底层库函数

# alignof 与 alignas

## alignof

```alignof``` 用于获取类型或对象的内存对齐要求，即该类型在内存中的起始地址必须是其对齐值的整数倍。

语法：

```c++
alignof(T);
alignof(decltype(var));
```

```alignof``` 返回类型 ```T``` 的内存对齐字节数（```std::size_t``` 类型）

结构体/类的对齐规则：

+ 结构体的对齐值由其最大对齐要求的成员决定
  
+ 编译器自动插入填充字节（padding）以满足对齐

## 应用





