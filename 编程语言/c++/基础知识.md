# 1. 请说出 static 和 const 关键字尽可能多的作用？
+ 函数体内 static 变量
  
  作用范围为函数体，不同于 auto 变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
+ 在模块内的static全局变量
  可以被模块内所有函数访问，但不能被模块外其他函数访问；
+ 在模块内的static函数
  只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内；
+ 在类中的 static 成员变量
  属于整个类所拥有，类的所有对象只有一份拷贝；
+ 在类中的 static 成员函数
  属于整个类所拥有，这个函数不接受 this 指针，因而只能访问类的的 static 成员变量；

const 关键字作用：
+ 修饰一个变量，阻塞变量被改变；
+ 对指针来说，指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
+ 在一个函数声明中，const可以修饰形参，这个参数在函数内部不能改变其值；
+ 对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量；
+ 对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为 “左值”；

# 2. 指针与引用有什么区别？
（1）引用必须被初始化，指针不必；
（2）引用初始化以后不能被改变，指针可以改变所指的对象；
（3）不存在指向空值的引用，但是存在指向空值的指针；

# 3. C++ 中extern的作用
作为一种面向对象的语言，C++支持函数重载，而过程式语言C不支持，函数被C++编译后再symbol库中的名字域C语言不同，为了实现C
和C++的混合编程，C++提供了C连接交换指定符号extern "C"来解决名字匹配问题，函数声明加上 extern "C"，则编译器会按照C语言的
方式编译。

# 4. 数组与指针的区别
+ 数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块；
+ 修改内容上的差别
  数组和指针都指向常量字符串。
+ sizeof 计算上的差别

# 5. const与#define 相比，有何优点？
const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
1）const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
2）有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。

# 6. C++ 是不是类型安全的？
不是。两个不同类型的指针之间可以强制转换。

# 7. main函数执行之前，还会执行什么代码？
全局对象的构造函数会在main函数之前执行。

# 8. 在什么时候需要使用 “常引用”？
即要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。

# 9. 将引用作为函数返回值类型的格式、好处和需要遵守的规则？
格式: 类型标识符& 函数名（形参列表及类型说明） {// 函数体}
好处：在内存中不产生被返回值的副本。
注意事项：
+ 不能返回局部变量的引用；
+ 不能返回函数内部new分配的内存的引用，导致内存无法释放；
+ 可以返回类成员的引用，但最好是 const；否则会破坏业务规则的完整性；
+ 流操作符重载返回值声明为“引用”的作用：

# 10. 介绍多态、虚函数和纯虚函数
多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；在程序编译时多态性体现在函数和运算符的重载上；

虚函数：在基类中冠以关键字 virtual 的成员函数。它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。

纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在的纯虚函数不具备函数的功能，一般不能直接被调用。

从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。

抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类是必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。

注：
定义一个函数为虚函数，不代表函数为不被实现的函数。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。定义一个函数为纯虚函数，才代表函数没有被实现。

# 11. 未初始化的全局变量和初始化的全局变量放在哪里？
初始化的全局变量存在在**数据段**，数据段数据静态分配；
未初始化的全局变量存放在 BSSS段，属于静态内存分配。

why:
（1） 从编译器和链接器处理过程分析：初始化过的变量需要在可执行文件里存储它们的初始值，未初始化的全局变量不需要在文件里占实际空间，只需要记录大小信息；
（2） 考虑可执行文件的大小：如果未初始化的变量也在文件里存一堆0，那文件会变得很大，尤其是遇到大数组的时候；
（3）从程序加载过程分析：初始化数据段(.data)的内容会被直接映射到内存，所以文件里有什么内存里就有什么，而未初始化数据段(.bss)在文件里只需要一个长度信息，加载时操作系统根据这个长度分配内存并清零。这样文件更小，加载也更快。

# 12. final 标识符的作用是什么？
（1）放在类的后面
标识该类无法被继承；
（2）放在虚函数后面
该虚函数无法被重写，表示阻止虚函数的重载；

# 13. 虚函数是怎么实现的？它存放在内存的哪个区？什么时候生成的？
虚函数实现原理两个关键概念：**虚函数表**和**虚函数指针**

虚函数表：每个包含虚函数的类都会生成一个虚函数表，其中存储着该类中所有虚函数的地址。虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码；

虚函数指针：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚函数表，这个指针指向该对象对应的虚函数表，从而让程序能够动态的调用虚函数；

当一个基类指针或引用调用虚函数时，编译器会使用虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。

在编译阶段生成，虚函数和普通函数一样存放在代码段，只是它的指针又存放在虚表之中。

