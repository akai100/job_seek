# 1. STL 相关
## 1.1 stl熟悉吗，vector、map、list、hashMap，vector底层，map引出红黑树。优先队列用过吗，使用的场景。无锁队列听说过吗，原理是什么（比较并交换）
(1) vector（动态数组）
底层实现：连续内存分配的动态数组。
核心特性：
随机访问：O(1)（通过下标直接访问）。
尾部插入/删除：均摊 O(1)（可能触发扩容）。
中间插入/删除：O(n)（需要移动元素）。
扩容机制：通常以2倍或1.5倍增长（reserve可预分配）。
适用场景：
需要频繁随机访问（如数组遍历）。
尾部操作多，中间操作少（如栈式结构）
(2) list（双向链表）
底层实现：双向链表（每个节点含前后指针）。
核心特性：
插入/删除：O(1)（已知节点位置时）。
随机访问：O(n)（需遍历）。
内存开销：每个元素额外存储两个指针（前驱和后继）。
适用场景：
频繁在任意位置插入/删除（如LRU缓存）。
不需要随机访问（如队列实现）。
(3) map（红黑树实现的键值对）
底层实现：红黑树（自平衡二叉搜索树）。
核心特性：
有序性：键按升序排列（默认std::less）。
插入/删除/查找：O(log n)。
内存开销：每个节点存储键、值、颜色标记和三个指针（父、左、右）。
为什么用红黑树？
平衡性：保证最坏情况下仍为O(log n)（相比AVL树减少旋转次数）。
支持有序遍历（begin()到end()）。
适用场景：
需要键值对且按键有序（如字典、排行榜）。
需要范围查询（如lower_bound）。
(4) unordered_map（哈希表）
底层实现：哈希表（数组+链表/红黑树解决冲突）。
核心特性：
插入/删除/查找：平均O(1)，最坏O(n)（哈希冲突时）。
无序性：键的顺序不可控（依赖哈希函数）。
内存开销：桶数组+链表节点（或红黑树节点）。
适用场景：
高频单点查询（如缓存、词频统计）。
不需要有序遍历（如快速去重）。
