# 1. 类对象的大小受哪些因素影响
+ 类的非静态成员变量大小，**静态成员**不占据类的空间，成员函数也不占据类的空间大小；
+ 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；
+ 虚函数的话，会在类对象插入 vptr 指针，加上指针大小；
  当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在派生类的空间中，也会对派生类进行扩展；

# 2. 基类的析构函数不是虚函数，会带来什么问题？
如果一个基类的析构函数不是虚函数，那么当通过基类指针删除派生类对象时，会导致派生类的析构函数不被调用，从而可能引起资源泄漏等问题。

```C++
Base* ptr = new Derived();
delete ptr; 
```
如果 Base 的析构函数不是虚函数，Derived的析构函数不会调用，如果Derived 类中存在资源，则会导致资源未释放。

# 3. 右值引用的作用
右值引用（Rvalue Reference）是 C++11 引入的核心特性，主要解决了深拷贝性能问题和转发效率问题。它的核心作用是实现移动语义（Move Semantics）和完美转发（Perfect Forwarding），显著提升程序性能。

# 4. 一个空类的大小
空类的大小是1，这是为了让对象的实例能够相互区别，具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，
因此，编译器会给空类隐含加上一个字节，这个空类实例化之后就会拥有独一无二的内存地址。
当空白类作为基类是，该类的大小就被优化为0，子类的大小就是子类本身的大小，这就是所谓的空白基类最优化。

# 5. 什么情况下会调用拷贝构造函数？
生成一个实例化的对象会调用一次普通构造函数，而用一个对象去实例化一个新的对象所调用的就是拷贝构造函数。
1）用类的一个对象去初始化另一个对象的时候；
2）当函数的参数是类的对象时，就是值传递的时候，如果是引用传递则不会调用；
3）当函数的返回值是类的对象或者引用的时候；

# 6. 静态绑定和动态绑定的介绍
静态绑定和动态绑定是C++多态性的一种特性
1）对象的静态类型和动态类型
静态类型：对象在声明时采用的类型，在编译时确定；
动态类型：当前对象所指的类型，在运行期决定，对象的动态类型可变，静态类型无法更改；
2）
