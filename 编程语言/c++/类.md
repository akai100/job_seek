# 1. 类对象的大小受哪些因素影响
+ 类的非静态成员变量大小，**静态成员**不占据类的空间，成员函数也不占据类的空间大小；
+ 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；
+ 虚函数的话，会在类对象插入 vptr 指针，加上指针大小；
  当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在派生类的空间中，也会对派生类进行扩展；

# 2. 基类的析构函数不是虚函数，会带来什么问题？
如果一个基类的析构函数不是虚函数，那么当通过基类指针删除派生类对象时，会导致派生类的析构函数不被调用，从而可能引起资源泄漏等问题。

```C++
Base* ptr = new Derived();
delete ptr; 
```
如果 Base 的析构函数不是虚函数，Derived的析构函数不会调用，如果Derived 类中存在资源，则会导致资源未释放。

# 3. 右值引用的作用
右值引用（Rvalue Reference）是 C++11 引入的核心特性，主要解决了深拷贝性能问题和转发效率问题。它的核心作用是实现移动语义（Move Semantics）和完美转发（Perfect Forwarding），显著提升程序性能。

# 4. 一个空类的大小
空类的大小是1，这是为了让对象的实例能够相互区别，具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，
因此，编译器会给空类隐含加上一个字节，这个空类实例化之后就会拥有独一无二的内存地址。
当空白类作为基类是，该类的大小就被优化为0，子类的大小就是子类本身的大小，这就是所谓的空白基类最优化。

# 5. 什么情况下会调用拷贝构造函数？
生成一个实例化的对象会调用一次普通构造函数，而用一个对象去实例化一个新的对象所调用的就是拷贝构造函数。
1）用类的一个对象去初始化另一个对象的时候；
2）当函数的参数是类的对象时，就是值传递的时候，如果是引用传递则不会调用；
3）当函数的返回值是类的对象或者引用的时候；

# 6. 静态绑定和动态绑定的介绍
静态绑定和动态绑定是C++多态性的一种特性
1）对象的静态类型和动态类型
静态类型：对象在声明时采用的类型，在编译时确定；
动态类型：当前对象所指的类型，在运行期决定，对象的动态类型可变，静态类型无法更改；
2）

# 7. virtual函数能声明为内联吗？为什么？
通常情况下是不能的，inline是编译期决定，他意味着在执行前就将调用动作替换为被调用函数的本体；
virtual是运行期决定，他意味着直道运行期才决定调用哪个函数。

# 8. 如果在构造函数和析构函数中抛出异常会发生什么？什么是栈展开
+ 构造函数抛异常
  不会发生资源泄漏。假设在operator new()时抛出异常，那么将会因异常而结束此次调用，内存分配失败，不可能存在内存泄露。假设在别处(operator new() )执行之后抛出异常，
  此时析构函数调用，已构造的对象将得以正确释放，且自动调用operator delete()释放内存。
+ 析构函数抛异常
  可以抛出异常，但该异常必须留在析构函数；若析构函数因异常退出，情况会很糟糕(all kinds of bad things are likely to happen)
a、可能使得已分配的对象未能正常析构，造成内存泄露；
b、例如在对像数组的析构时，如果对象的析构函数抛出异常，释放代码将引发未定义行为。考虑一个对象数组的中间部分在析构时抛出异常，它无法传播，因为传播的话将使得后续部分不能正常释放；它也无法吸收，因为这违反了”异常中立“原则(异常中立，就是指任何底层的异常都会抛出到上层，也就相当于是异常透明的)。
(2)、抛出异常时，将暂停当前函数的执行，开始查找匹配的catch子句。首先检查throw本身是否在try块内部如果是，检查与该try相关的catch子句，看是否可以处理该异常。如果不能处理，就退出当前函数，并且释放当前函数的内存并销毁局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的catch。

# 9. 如何初始化const和static数据成员？
+ const 成员必须在 构造函数的初始化列表 中初始化（因为它不能被赋值）;
+ static const 成员（C++11 起支持类内初始化）
  只有 整型（int, char, long）和枚举 可以在类内初始化 static const。
  其他类型（如 double, std::string）必须在类外定义：
+ static数据成员
  （1）传统方式，在cpp文件中初始化
  （2）C++17 支持 inline static
  

