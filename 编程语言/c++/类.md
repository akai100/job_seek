# 1. 类对象的大小受哪些因素影响
+ 类的非静态成员变量大小，**静态成员**不占据类的空间，成员函数也不占据类的空间大小；
+ 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；
+ 虚函数的话，会在类对象插入 vptr 指针，加上指针大小；
  当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在派生类的空间中，也会对派生类进行扩展；

# 2. 基类的析构函数不是虚函数，会带来什么问题？
如果一个基类的析构函数不是虚函数，那么当通过基类指针删除派生类对象时，会导致派生类的析构函数不被调用，从而可能引起资源泄漏等问题。

```C++
Base* ptr = new Derived();
delete ptr; 
```
如果 Base 的析构函数不是虚函数，Derived的析构函数不会调用，如果Derived 类中存在资源，则会导致资源未释放。

# 3. 右值引用的作用
右值引用（Rvalue Reference）是 C++11 引入的核心特性，主要解决了深拷贝性能问题和转发效率问题。它的核心作用是实现移动语义（Move Semantics）和完美转发（Perfect Forwarding），显著提升程序性能。

# 4. 一个空类的大小
空类的大小是1，这是为了让对象的实例能够相互区别，具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，
因此，编译器会给空类隐含加上一个字节，这个空类实例化之后就会拥有独一无二的内存地址。
当空白类作为基类是，该类的大小就被优化为0，子类的大小就是子类本身的大小，这就是所谓的空白基类最优化。
